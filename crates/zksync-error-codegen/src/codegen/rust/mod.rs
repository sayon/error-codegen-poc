pub mod config;
pub mod error;
pub mod files;
pub mod util;

pub use config::Config as RustBackendConfig;
use error::GenerationError;
use proc_macro2::TokenStream;
use util::codegen::ident;
use util::codegen::sanitize;
use zksync_error_model::inner::ComponentMetadata;
use zksync_error_model::inner::DomainMetadata;
use zksync_error_model::unpacked::UnpackedModel;

use zksync_error_model::error::ModelValidationError;
use zksync_error_model::inner::ErrorDescription;
use zksync_error_model::inner::FullyQualifiedTargetLanguageType;
use zksync_error_model::inner::Model;

use super::Backend;
use super::File;

pub struct RustBackend {
    model: Model,
    all_domains: Vec<TokenStream>,
    all_domain_codes: Vec<TokenStream>,
}

impl Backend<RustBackendConfig> for RustBackend {
    type Error = GenerationError;

    fn get_name() -> &'static str {
        "rust"
    }

    fn generate(&mut self, config: &RustBackendConfig) -> Result<Vec<File>, Self::Error> {
        Ok(vec![
            self.generate_file_error_definitions(config)?,
            self.generate_file_error_domains()?,
            self.generate_file_documentation()?,
            self.generate_file_error_mod()?,
            self.generate_file_identifier()?,
            self.generate_file_kind()?,
            self.generate_file_lib()?,
            self.generate_file_packed()?,
            self.generate_file_serialized()?,
            self.generate_file_untyped()?,
            self.generate_file_cargo(config)?,
            File {
                relative_path: "resources/error-model-dump.json".into(),
                content: {
                    let unpacked: UnpackedModel =
                        zksync_error_model::unpacked::flatten(&self.model);
                    let user_facing_model: zksync_error_description::ErrorHierarchy =
                        unpacked.into();
                    serde_json::to_string_pretty(&user_facing_model.wrap())?
                },
            },
        ])
    }

    fn get_language_name() -> &'static str {
        "rust"
    }
}

impl RustBackend {
    pub fn new(model: &Model) -> Self {
        let all_domains: Vec<_> = model
            .domains
            .values()
            .cloned()
            .map(|domain| ident(&Self::domain_type_name(domain.meta.as_ref()).unwrap()))
            .collect();

        let all_domain_codes: Vec<_> = model
            .domains
            .values()
            .cloned()
            .map(|domain| ident(&Self::domain_code_type_name(domain.meta.as_ref()).unwrap()))
            .collect();

        Self {
            model: model.clone(),
            all_domains,
            all_domain_codes,
        }
    }

    fn format_with_preamble(contents: impl ToString) -> Result<String, rustfmt_wrapper::Error> {
        rustfmt_wrapper::rustfmt(format!(
            r#"
//!
//! AUTOGENERATED BASED ON A SET OF JSON FILES, DO NOT EDIT MANUALLY
//!

{}
"#,
            contents.to_string()
        ))
    }
    fn type_as_rust(typ: &FullyQualifiedTargetLanguageType) -> String {
        let FullyQualifiedTargetLanguageType { name, path } = typ;
        if path.is_empty() {
            name.to_string()
        } else {
            format!("{path}.{name}")
        }
    }

    fn get_rust_type(&self, name: &str) -> Result<String, GenerationError> {
        let typ = self.model.get_type(Self::get_language_name(), name)?;
        Ok(Self::type_as_rust(typ))
    }

    fn component_type_name(component: &ComponentMetadata) -> Result<String, GenerationError> {
        let name = component
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelValidationError::UnmappedName(component.name.clone()))?;

        Ok(name.to_string())
    }
    fn component_code_type_name(component: &ComponentMetadata) -> Result<String, GenerationError> {
        let name = component
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelValidationError::UnmappedName(component.name.clone()))?;

        Ok(format!("{name}Code"))
    }

    fn domain_type_name(domain: &DomainMetadata) -> Result<String, GenerationError> {
        let name = domain
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelValidationError::UnmappedName(domain.name.clone()))?;

        Ok(name.to_string())
    }

    fn domain_code_type_name(domain: &DomainMetadata) -> Result<String, GenerationError> {
        let name = domain
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelValidationError::UnmappedName(domain.name.clone()))?;

        Ok(format!("{name}Code"))
    }
    fn domain_code_ident(domain: &DomainMetadata) -> TokenStream {
        ident(&Self::domain_code_type_name(domain).expect("Internal error"))
    }
    fn domain_ident(domain: &DomainMetadata) -> TokenStream {
        ident(&Self::domain_type_name(domain).expect("Internal error"))
    }
    fn component_code_ident(component: &ComponentMetadata) -> TokenStream {
        ident(&Self::component_code_type_name(component).expect("Internal error"))
    }
    fn component_ident(component: &ComponentMetadata) -> TokenStream {
        ident(&Self::component_type_name(component).expect("Internal error"))
    }
    fn component_error_alias_ident(component: &ComponentMetadata) -> TokenStream {
        ident(&format!(
            "{}Error",
            &Self::component_type_name(component).expect("Internal error")
        ))
    }

    fn error_variant_name(error: &ErrorDescription) -> Result<String, GenerationError> {
        let name = error
            .bindings
            .get(Self::get_language_name())
            .ok_or(ModelValidationError::UnmappedName(error.name.clone()))?;
        Ok(sanitize(&name.name))
    }

    fn error_ident(error: &ErrorDescription) -> TokenStream {
        ident(&Self::error_variant_name(error).expect("Internal error"))
    }
}
